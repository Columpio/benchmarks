(* Integers implemented using natural numbers *)
module A
  use HighOrd
  type sign = Pos | Neg
  type nat = Z | S nat
  type z = P nat | N nat
  function minus (ds : nat) (ds2 : nat) : z =
    match ds with
    | Z ->
        match ds2 with
        | Z -> P Z
        | S n -> N n
        end
    | S m ->
        match ds2 with
        | Z -> P ds
        | S n2 -> minus m n2
        end
    end
  function abs' (ds3 : z) : nat =
    match ds3 with
    | P n3 -> n3
    | N n4 -> S n4
    end
  function opposite (ds4 : sign) : sign =
    match ds4 with
    | Pos -> Neg
    | Neg -> Pos
    end
  function sign2 (ds5 : z) : sign =
    match ds5 with
    | P ds6 -> Pos
    | N ds7 -> Neg
    end
  function timesSigns (ds8 : sign) (x : sign) : sign =
    match ds8 with
    | Pos -> x
    | Neg -> opposite x
    end
  function toInteger (ds9 : sign) (n5 : nat) : z =
    match ds9 with
    | Pos -> P n5
    | Neg ->
        match n5 with
        | Z -> P Z
        | S m2 -> N m2
        end
    end
  function plus (ds10 : nat) (m3 : nat) : nat =
    match ds10 with
    | Z -> m3
    | S n6 -> S (plus n6 m3)
    end
  function mult (ds11 : nat) (m4 : nat) : nat =
    match ds11 with
    | Z -> Z
    | S n7 -> plus m4 (mult n7 m4)
    end
  function times (i : z) (j : z) : z =
    toInteger (timesSigns (sign2 i) (sign2 j)) (mult (abs' i) (abs' j))
  function plus2 (ds12 : z) (ds13 : z) : z =
    match ds12 with
    | P m5 ->
        match ds13 with
        | P n8 -> P (plus m5 n8)
        | N n9 -> minus m5 (S n9)
        end
    | N m6 ->
        match ds13 with
        | P n10 -> minus n10 (S m6)
        | N n11 -> N (S (plus m6 n11))
        end
    end
  goal prop_left_distrib :
    forall x2 : z, y : z, z2 : z .
      times x2 (plus2 y z2) = plus2 (times x2 y) (times x2 z2)
end
