(* Skew heaps *)
module A
  use HighOrd
  type nat = Z | S nat
  type heap = Node heap nat heap | Nil
  type list 'a = Nil2 | Cons 'a (list 'a)
  function le (ds : nat) (ds2 : nat) : bool =
    match ds with
    | Z -> True
    | S d ->
        match ds2 with
        | Z -> False
        | S d2 -> le d d2
        end
    end
  function listInsert (x : nat) (ds3 : list nat) : list nat =
    match ds3 with
    | Nil2 -> Cons x Nil2
    | Cons y ys ->
        match le x y with
        | False -> Cons y (listInsert x ys)
        | True -> Cons x ds3
        end
    end
  function merge (ds4 : heap) (q : heap) : heap =
    match ds4 with
    | Node d3 d4 d5 ->
        match q with
        | Node d6 d7 d8 ->
            match le d4 d7 with
            | False -> Node (merge ds4 d8) d7 d6
            | True -> Node (merge d5 q) d4 d3
            end
        | Nil -> ds4
        end
    | Nil -> q
    end
  function insert (x2 : nat) (h : heap) : heap =
    merge (Node Nil x2 Nil) h
  function toList' (ds5 : nat) (ds6 : heap) : list nat =
    match ds5 with
    | Z -> Nil2
    | S d9 ->
        match ds6 with
        | Node d10 d11 d12 -> Cons d11 (toList' d9 (merge d10 d12))
        | Nil -> Nil2
        end
    end
  function plus (ds7 : nat) (m : nat) : nat =
    match ds7 with
    | Z -> m
    | S n -> S (plus n m)
    end
  function heapSize (ds8 : heap) : nat =
    match ds8 with
    | Node l ds9 r -> plus (heapSize l) (heapSize r)
    | Nil -> Z
    end
  function toList (h2 : heap) : list nat = toList' (heapSize h2) h2
  goal prop_insert :
    forall x3 : nat, h3 : heap .
      toList (insert x3 h3) = listInsert x3 (toList h3)
end
