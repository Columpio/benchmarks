(* Skew heaps *)
module A
  use HighOrd
  type maybe 'a = Nothing | Just 'a
  type nat = Z | S nat
  type heap = Node heap nat heap | Nil
  type list 'a2 = Nil2 | Cons 'a2 (list 'a2)
  function le (ds : nat) (ds2 : nat) : bool =
    match ds with
    | Z -> True
    | S d ->
        match ds2 with
        | Z -> False
        | S d2 -> le d d2
        end
    end
  function listDeleteMinimum (ds3 : list nat) : maybe (list nat) =
    match ds3 with
    | Nil2 -> Nothing
    | Cons ds4 xs -> Just xs
    end
  function merge (ds5 : heap) (q : heap) : heap =
    match ds5 with
    | Node d3 d4 d5 ->
        match q with
        | Node d6 d7 d8 ->
            match le d4 d7 with
            | False -> Node (merge ds5 d8) d7 d6
            | True -> Node (merge d5 q) d4 d3
            end
        | Nil -> ds5
        end
    | Nil -> q
    end
  function deleteMinimum (ds6 : heap) : maybe heap =
    match ds6 with
    | Node l ds7 r -> Just (merge l r)
    | Nil -> Nothing
    end
  function toList' (ds8 : nat) (ds9 : heap) : list nat =
    match ds8 with
    | Z -> Nil2
    | S d9 ->
        match ds9 with
        | Node d10 d11 d12 -> Cons d11 (toList' d9 (merge d10 d12))
        | Nil -> Nil2
        end
    end
  function plus (ds10 : nat) (m : nat) : nat =
    match ds10 with
    | Z -> m
    | S n -> S (plus n m)
    end
  function heapSize (ds11 : heap) : nat =
    match ds11 with
    | Node l2 ds12 r2 -> plus (heapSize l2) (heapSize r2)
    | Nil -> Z
    end
  function toList (h : heap) : list nat = toList' (heapSize h) h
  function maybeToList (ds13 : maybe heap) : maybe (list nat) =
    match ds13 with
    | Nothing -> Nothing
    | Just x -> Just (toList x)
    end
  goal prop_deleteMinimum :
    forall h2 : heap .
      listDeleteMinimum (toList h2) = maybeToList (deleteMinimum h2)
end
