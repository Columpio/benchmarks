(* Integers implemented using natural numbers *)
module A
  use HighOrd
  type sign = Pos | Neg
  type nat = Z | S nat
  type z = P nat | N nat
  function abs' (ds : z) : nat =
    match ds with
    | P n -> n
    | N n2 -> S n2
    end
  function one : z = P (S Z)
  function opposite (ds2 : sign) : sign =
    match ds2 with
    | Pos -> Neg
    | Neg -> Pos
    end
  function sign2 (ds3 : z) : sign =
    match ds3 with
    | P ds4 -> Pos
    | N ds5 -> Neg
    end
  function timesSigns (ds6 : sign) (x : sign) : sign =
    match ds6 with
    | Pos -> x
    | Neg -> opposite x
    end
  function toInteger (ds7 : sign) (n3 : nat) : z =
    match ds7 with
    | Pos -> P n3
    | Neg ->
        match n3 with
        | Z -> P Z
        | S m -> N m
        end
    end
  function plus (ds8 : nat) (m2 : nat) : nat =
    match ds8 with
    | Z -> m2
    | S n4 -> S (plus n4 m2)
    end
  function mult (ds9 : nat) (m3 : nat) : nat =
    match ds9 with
    | Z -> Z
    | S n5 -> plus m3 (mult n5 m3)
    end
  function times (i : z) (j : z) : z =
    toInteger (timesSigns (sign2 i) (sign2 j)) (mult (abs' i) (abs' j))
  goal prop_mul_ident_left : forall x2 : z . x2 = times one x2
end
